.. _django:

******
Django
******


Вовед во Django
---------------
Django  претставува Python Framework која што овозможува брзо развивање на 
web апликации со python код. Django  е open source со BCD  лиценца, што значи 
неговиот код е целосно достапен.
Django  како web framework овозможува пишување на серверски код и рендерирање 
на front end  темплејти. Во понатамошното излагање ќе се задржиме само на 
серверските карактеристи што ги овозможува django во комбинација со tastypie 
за кои што ќе зборуваме подоцна. 
Django во голема мера ја следи MVC архитектурата при што има интегрирано 
сопствено ORM  за работа со база, кое што доста го олеснува процесот на работа 
со податоци. За секој проект да биде своја засебна целина и да 
користи посебна python околина користиме ``vitrualenv``. Пред да почнеме со 
креирање на проектот потребно е да креираме виртуелна околина во која што ќе 
биде сместен истиот и која што ќе го користи нејзиниот python интерпретер.

За да може да се креира виртуелна околина потребно е да се инсталира 
``easy_install`` со кои што ќе можеме да ги исталираме најновите python пакети 
кои што ни се потребни во апликацијата. ::

   sudo apt-get install python-setuptools

Потоа со помош на него се инсталира virtualenv за креирање на виртуелна python 
околина. ::

   sudo easy_install virtualenv

Следен чекор е креирање на виртуелна околина за проектот. ::

   virtualenv <project_name>
  
За ова потребно е да бидеме во фолдерот каде што сакаме да  биде сместена 
виртуелна околина.
Пред да се направи активација на виртуелната околина потребно е да се направи 
уште едно подесување во ``bin/activate`` фајлот. На крајот од самиот фајл 
потребно е да се внесат следните линии код ::
   
   # Django
   export PYTHONPATH="$VIRTUAL_ENV/project"
   export DJANGO_SETTINGS_MODULE=settings
   # Aliases for easier operation
   alias run='$VIRTUAL_ENV/project/run_local_server.sh'

Всушност со овие три линии код ја додаваме патеката на проектот во pythonpath, 
после тоа го дефинираме django_settings_module и последната линија 
овозможува стартување на серверот со run команда од кој било директориум кога 
сме во активна виртуелна околина.

Наредено што треба да се направи е активација на истата ::
   
   . bin/activate

Откако сме веќе во виртуелната околина потребно е да ги исталираме дополнителните
пакети за проектот како на пример: ``django, tastypie, django-extensions``. 
Бидејќи бројот на дополнителни пакети може да биде доста голем за подобра 
организација најдобро е истите да ги сместиме во посебен 
текст фајл ``REQUIREMENTS`` така што подоцна при исталирање го читаме овој
фајл и ги исталираме пакетите наведени во него ::
   
   pip install -r  REQUIREMENTS
 
За креирање на django  проект повеќе информации можат да се најдат на следниов 
`линк <https://docs.djangoproject.com/en/1.5/intro/tutorial01/>`_

Во нашиов туториал работиме со веќе креиран проект кои ги има само 
основните конфигурациски фајлови.

Како развојна околина се користи Eclipse со инсталиран ``pydev`` додаток за python.
Наредно што треба да се направи е import на проектот во Eclipse.
На `линкот <http://vaboone.wordpress.com/2010/11/22/import-a-django-project-into-eclipse/>`_ 
детално е објаснето како да го внесете вашиот django проект во Eclipse.

Еден django проект се состои од една или повеќе апликации. 
Постојат различни структурирања на django проектите во зависност од обемот и 
потребите на истиот. 

Секоја апликација се состои од нејзини пакети('api', 'models', 'tests') кои што 
се составени од посебни модули за секоја целина одделно. На овој начин 
секоја целина од кодот посебно е одвоена и поедноставна како за развивање така и за 
понатамошно одржување.
Нареден чекор е да се направи основните подесувања во ``settings`` фајлот на проектот.
Детално објасување за истиот можете да најдате во django документацијата. 
Најголемиот дел од параметрите за конкретниов проект можат да си останат 
како што се моментално. Единствено потребно е да се исконфигурира 
базата на податоци која што ќе ја користи проект.
За овој проект ќе се користи sqlite3 база на податоци.

За да провериме дали проектот правилно е подесен го стартуваме 
серверот со скриптата ::
   
   ./run_local_server
 
И во интернет прелистувач венсуваме ``127.0.0.1:8000/admin/`` 
При што треба да се појаву admin панелот.

Модели
------

Моделите овозможуваат на поедноставен начин да се даде репрезентација на 
структурата на база на податоци на апликацијата и многу поедноставно работење 
со истата.
Секоја  python класа  со сабкласа ``django.db.models.Model`` претставува модел.
Секој модел најчесто репрезентира една табела во базата на податоци, а секое од 
полињата дефинирани во моделот соодветна колона во табелата. 
Останатите атрибути на класата ги додефинираат преостанатите однесувања на 
податоците од табелата. Сето ова погоре напишано во код би изгледало вака ::

   from django.db import models

   class Person(models.Model):
       class Meta:
           app_label = 'app'
   
       first_name = models.CharField(max_length=100)
       last_name = models.CharField(max_length=100)
       birthday = models.DateField(null=True, blank=True)
   
       def __unicode__(self):
           return u'{0} {1}'.format(self.first_name, self.last_name)

Со креирање на класа ``Person`` со сабкласа  ``models.Model`` креиравме 
django модел со име ``Person`` кои што репрезентира соодветна табела во базата 
на податоци. Во ``Meta`` класата ги дополнуваме дополнителните атрибути како 
име на апликација на која припаѓа овој модел во конкретниот случај app 
исто така овде може да се дополнат подесувања како што се: 
сортирање на податоци, полиња кои што мора да 
бидат различни итн. Подетално објаснување за Meta класата може да најдете
`овде <https://docs.djangoproject.com/en/1.5/topics/db/models/#meta-options>`_.

Во Вториот дел од класата има дефинирано неколку полиња кои што претставуваат 
карактеристики на Person конкретно негово име и презиме и датум на раѓање, 
овие полиња се дефинирани со соодветен тип на податоци кои што можат да го 
содржат, во првите два случаеви тоа е текст податок со максимална должина од 
100 карактери, додека во вториот случај податокот мора да биде датум и притоа во 
овој случај е дефинирано дека ова поле не е задолжително односно може да 
поприма и null вредност. За подетално објаснување следете го 
`линкот  <https://docs.djangoproject.com/en/1.5/topics/db/models/#fields>`_.

Последниот дел од овој модел е ``__unicode__`` методот. Овој метод всушност 
дава дескриптивно прикажување на секој објект од моделот така доколку во 
командна линија направиме пребарување за сите Person родени пред 2012 како 
резултат ќе ги добиеме објектите репрезентирани со нивното име и презиме. 
Подетално објаснување за ``__unicode__`` може да најдете на 
`линкот <https://docs.djangoproject.com/en/1.5/ref/models/instances/#django.db.models.Model.__unicode__>`_.

Откако ќе бидат напишани моделите потребно е да се направи синхронизација на 
база со што ќе бидат искреирани табели за сите нови модели. 
Да напоменам дека доколку структурата на самиот проект е како во конкретниот случај 
односно со пакети кои содржат соодветни модули потребно е секој модел да биде 
импортуван во ``init`` модулот на  соодветниот пакет.


Модели во SocialNet
-------------------

Да преминеме на креирање на модели во social-net апликација. 
Истата треба да биде организирана во 4 модели така што како пример ќе 
бидат искреирни два од нив сега а останатите ќе бидат како 
задача да ги направите сами.

Најпрвин потребно е да креираме нов модул contact во кој што ќе биде сместен 
овој модел.
Person  е моделот кои што како пример ќе биде искреиран. Овој модел е 
карактеристичен и поради тоа што истиот наследнува од веќе постоечки модел 
односно од User моделот кои што  го има во django и се користи за аутентикација 
на корисниците. За овој модел потребно е да прочитате 
`подетално <https://docs.djangoproject.com/en/dev/topics/auth/default/#user-objects>`_

Person моделот репрезентиран со код изгледа вака::

   from django.db import models
   from django.contrib.auth.models import User
   
   NA, MALE, FEMALE = 0, 1, 2
   GENDERS = ((NA, 'Not Available'), (MALE, 'Male'), (FEMALE, 'Female'))
   GENDERS_MAP = {'NA': NA, 'MALE': MALE, 'FEMALE': FEMALE}
   
   class Person(User):
       class Meta:
           app_label = 'app'
   
       gender = models.IntegerField(choices=GENDERS, default=NA)
       description = models.CharField(max_length=300, blank=True)
       phone = models.CharField(max_length=50, null=True, blank=True)
       birthday = models.DateField(null=True, blank=True)
   
       def __unicode__(self):
           return u'{0} {1}'.format(self.first_name, self.last_name)
    

Овој модел ги содржи сите полиња од ``User`` моделот плус дополнетите во истиот 
како што се ``gender, description, phone, birthday``.
Од овие полиња ке се задржиме само на кратко на ``gender`` кој што преставува 
поле од тип ``int`` со специфичен параметар ``choices`` што би значело дека може 
да поприма вредност само од понудените во ``GENDERS``. Подетално за оваа 
можност следете го 
`линкот <https://docs.djangoproject.com/en/1.5/ref/models/fields/#choices>`_

Вториот модел во оваа апликација има за цел да овозможи поврзување на 
корисниците помеѓу себе како пријатели. Со тоа што откако иницијаторот на ова 
пријателство ќе испрати понуда вториот корисник мора да ја одобри истата. 
Овој модел мора да содржи полиња за два корисници, видот на релација кои 
го имаа тие(Пријатели, Роднини итн.) и дали релацијата помеѓу нив е активна. 
Сето тоа репрезентирано со код изгледа вака::

   FRIEND, COUPLE, CLASSMATE, ROOMMATE, FAMILY = range(5, 10)
   RELATIONS = ((FRIEND, 'Friend'), (COUPLE, 'Couple'), (CLASSMATE, 'Classmate'),
                (ROOMMATE, 'Roommate'), (FAMILY, 'Family'))
   
   RELATIONS_MAP = {'FRIEND': FRIEND, 'COUPLE': COUPLE, 'CLASSMATE': CLASSMATE,
                    'ROOMMATE': ROOMMATE, 'FAMILY': FAMILY}
   
   class ContactRelation(models.Model):
       class Meta:
           app_label = 'app'
   
       updated = models.DateTimeField(auto_now=True)
   
       first_contact = models.ForeignKey(Person, related_name='first_contact_rel')
       second_contact = models.ForeignKey(Person,
                                          related_name='second_contact_rel')
       relation = models.IntegerField(choices=RELATIONS)
   
       accepted = models.BooleanField(default=False)
   
       def __unicode__(self):
           return u'{0} is {1} with {2}'.format(self.first_contact,
                                               self.second_contact,
                                               self.get_relation_display())
 
Како што претходно спомнавме потребни се две релации во овој модел со два 
корисника  ова репрезентирано во код изгледа како во горниот пример а неговото 
значење е дека имаме релација со моделот ``Person`` и тоа секоја 
``ContactRelation`` може да има само еден ``first_contact`` додека секој 
``person`` може да биде ``first_contact`` во повеќе ``ContactRelation``.

Постојат неколку типови на релации помеѓу моделите и тоа:
   * OneToOne 
   * ManyToOne(ForeignKey)
   * ManyToMany

Подетално за овие релации може да прочитате 
`овде <https://docs.djangoproject.com/en/1.5/topics/db/models/#relationships>`_

Откако имаме корисници и релација помеѓу нив ваша задача ќе биде да направите 
модели кои што ќе им овозможат на корисниците да направат одреденa активност на 
нивната страна односно да напшаат одредено мислење кое што подоцна останатите 
корисници можат да го ископираат на нивниот профил или пак да остават коментар 
за истот. Што значи потребни се два дополнителни модели :

``Activity`` со следниве карактеристики:
* Датум кога е направена оваа активност
* Од кого е креиран оваа активност
* Содржина на активноста
* Број на копии од страна на останатите корисници
* Дали оваа активност можат да ја гледаат сите корисници или само неговите пријатели

За да се овозможат коментари на активноста потребно е да се креира дополнителен 
модел ``Comment`` кои што би го карактеризирале следниве карактеристики:
* Датум кога е напишан коментарот
* За која активност се однесува коментарот
* Кој го напишал

Но претходно пред да започнете со креирање на овие модели истите потребно е да 
ги сместите во нов модул ``activity``.


Интеракција со податоци во Django
---------------------------------
Откако се искреирани моделите и веќе ги има сите потребни табели во база, 
потребно е податоците примени од клиент страната да бидат снимани во 
соодветните табели, истите да бидат едитирани или можеби избришани. 
Исто така клиентот потребно е да прикаже одреден дел од податоците надворешно. 
Целата оваа интеракција со податоците django ја овозможува преку сопствено 
``database-abstraction API``. Ова API ги овозможува сите претходно спомнати 
потребни акции. За секоја од нив ќе дадеме краток пример во продолжение.

Доколку е потребно да се искреира нов објек од ``Person`` моделот 
репрезентирано во код тоа изгледа вака::

      person = Person(first_name='Test', last_name='Person',
                       birthday=''2002-08-25)
      person.save()
      
Со ова веќе има искреирано нов објект од моделот ``Person`` и истиот е зачуван 
во соодветна табела. Доколку е потребно сега да се промени неговото име 
тоа би изгледало вака::

      person.first_name = 'New'
      person.save(update_fields=['first_name'])
      
Со оваа промена во база се промени само ``first_name`` полето и сега објектот 
``person`` е со име New.

Доколку по некое време потребно е да се избрише овој објект тоа се прави на 
следниов начин::

      person.delete()
      
Голем е бројот на случаеви кога е потребно да се извлече одредена информација 
од база и да се прикаже на клиентска страна. Django тоа го овозможува на релативно 
едноставен начин иако сепак зависи од тоа колку е сложен самиот филтер за 
информацијата што треба да се земе. Така на пример доколку е потребно да се 
прикажат сите person објекти  со име ``Alex`` тоа изгледа вака::

      alex_persons = Person.objects.filter(first_name='Alex'))
      
Доколку пак потребно е да се изостават сите што имаат презиме ``Deanovski`` 
потребно е да се напише следново пребарување::
   
      persons_without_deanovski = Person.objects.exclude(last_name='Deanovski'))
      
Ова се само неколку примери но Django овозможува многу посложени пребарувања 
за да дознаете многу повеќе за нив следат неколку линкови што потребно е да ги 
разгледате детално:

* https://docs.djangoproject.com/en/1.5/topics/db/queries/
* https://docs.djangoproject.com/en/1.5/ref/models/querysets/
* https://docs.djangoproject.com/en/1.5/topics/db/aggregation/

Исто така да напоменам дека доколку природата на пребарувањето е толку сложена 
што ова Django API  не може да го направи истот, може да се 
искористат дирекни SQL пребарувања во база, поопширно за ова може да најдете 
`овде <https://docs.djangoproject.com/en/1.5/topics/db/sql/>`_.
  
Креирање на  методи во SocialNet
--------------------------------
За да се продолжи со оваа целина потребно е претходната задача за креирање на 
двата дополнителни модели да биде завршена. Ја објаснивме накратко интеракцијата 
помеѓу Django и базата на податоци. Сега потребно е да се примени сето тоа 
во проектот.

Секој корисник може да креира свој профил и притоа истиот да го едитира, 
во случај да не сака неговиот профил да биде повеќе активен потребно е да има 
опција да направи деактивирање на истиот. За сето ова да му биде овозможено на 
корисникот потребно е да направиме неколку методи во Person моделот и тоа:
- Метод за креирање на нов корисник
- Метод за едитирање на податоците
- Метод за деактивирање на профил

Да започнеме по ред. Го објаснивме начинот за додавање на нов објект во самата 
база на податоци со помош на django меѓутоа многу често има потреба да се 
провери дали некои услов е задоволен пред да се искреира објектот затоа 
потребно е да се креира посебен метод во моделот Person кој што освен што ќе го 
искреира новиот објект ќе ги направи и сите дополнителни проверки и средување 
на податоците во формат каков што е потребен за истите да се снимаат во база.

Методот за креирање на нов корисник односно објект од моделот 
Person изгледа вака::

   @staticmethod
    def create_person(first_name, last_name, username, password, email,
                      gender=None, description='', phone=None, birthday=None):

        if not gender:
            gender = 'NA'

        person = Person(first_name=first_name, last_name=last_name,
                        username=username, email=email,
                        gender=GENDERS_MAP[gender], description=description,
                        phone=phone, birthday=birthday)
        person.set_password(password)

        person.save()

        return person

Методите кои што не се поврзани со конкретна инстанца од моделот мора да бидат 
статични методи, тоа се прави со додавање декоратор на методот ``staticmethod``. 
На овој начин методот се повикува преку моделот Person, за разлика од другите 
методи што се повикуваат преку инстанца од моделот Person.
Дополнителни работи што е потребно да се направат во овој метод е на ``gender`` 
променливата да и се додели default вредност доколку истата не е проследена и 
лозинката на корисникот најпрвин мора да биде ``hashed`` пред да се зачува во база. 
`Повеќе <https://docs.djangoproject.com/en/1.5/topics/auth/passwords/>`_ 
информации за тоа како django ги зачувува лозинките во база и 
целосната негова интеракција со истите.


Откако овој метод е креиран и веќе креираните тестови за истиот се успешни 
се преминува на креирање на нов метод за промена на профил на корисник. 
Во овој метод клиентската страна потребно е да ги испрати до серверот само 
полињата што се променети на тој начин се прави update само на тие полиња 
во база. Нема потреба да се прави непотребен update на полињата што ја имаат 
истата вредност. 
Во продолжение е даден методот. ::

   def update_person(self, user, **kwargs):
        update_fields = kwargs.keys()

        for field in update_fields:
            field_value = kwargs[field]

            if field == 'gender':
                self.gender = GENDERS_MAP[field_value]

            elif hasattr(self, field):
                setattr(self, field, field_value)

        self.save(update_fields=update_fields)

        return
 
Со овој метод се прави update на секое поле што корисникот го променил со тоа што 
во еден ``for`` циклус поминуваме низ сите полиња пратени од клиентска страна 
и на секое од нив им ја доделуваме новата вредност за на крај да ја зачуваме промената. 
Потребно е за податоците кои што не се во соодветниот формат каков што ги 
очекува базата истите да се форматираат поради тоа треба да внимаваме кога го 
едитираме полето ``gender``. На крај доколку е потребно да се врати вредност на 
клиентот истата е во dict формат доколку не единствено излегуваме 
со return.

Промената на лозинка е специфична ситуација која што потребно е да ја обработиме 
во посебен метод кој што изгледа вака::
   
   def reset_password(self, user, old_password, new_password):
        '''
            Only user could reset the password with
            inserting old and new password
        '''
        if not self.check_password(old_password):
            raise Exception('Old password does not match.')

        self.set_password(new_password)
        self.save(update_fields=['password'])

        return 
  
Пред да ја промени корисникот својата лозинка потребно е заради безбедносни 
причини да се провери неговата стара лозинка. Ако овој услов е успшен новата 
лозинка се зачувува во база. Потребно е да се проверуват претходно креираните 
тестови за оваа целина доколку се е во ред се преоѓа на следниот метод.

Наредниот метод се однесува на деактивирање на веќе активен корисник. 
Се што треба да се направи во овој случај е да се промени полето ``is_active`` 
од `True` во `False`::

   def remove_person(self, user):
        '''
            Person will not be remove permanently from the system,
            only is_active flag will be set to False
        '''
        self.is_active = False
        self.save(update_fields=['is_active', ])

        return
 

Откако сите методи за овој модел се готови се преминува кон креирање на 
методите кои што се потребни во моделот ``ContactRelation``.
Методите во овој модел потребно е да овозможат креирање на нова релација помеѓу 
два корисника, едитирање на таа релација и бришење на истата.
Во продолжение ќе биде објаснет методот за креирање на нова релација помеѓу два 
корисника додека останатите ќе биде потребно да ги направите сами::

   @staticmethod
    def add_relation(user, second_contact_id, relation):

        if ContactRelation.objects.filter(
                            Q(first_contact__pk=user.pk,
                            second_contact__pk=second_contact_id) |
                            Q(first_contact__pk=second_contact_id,
                            second_contact__pk=user.pk)).count() > 0:
            raise Exception("This two contacts have been already in relation.")

        first_contact = user
        second_contact = Person.objects.get(pk=second_contact_id)

        rel = ContactRelation(first_contact=first_contact,
                              second_contact=second_contact,
                              relation=RELATIONS_MAP[relation])
        rel.save()

        return rel

Потребно е најпрвин да се провери дали овие два корисници веќе немаат релација 
помеѓу себе. Доколку немаат, може да се креира истата, но претходно потребно 
е да се земе од база како објект вториот корисник со кои што моментално 
логираниот корисник сака да воспостави релација. Секогаш релациските полиња во 
Django моделите како влезен аргумент бараат објект од ист тип како и релацијата. 
Откако е искреирана новата релација потребно е овој објект да биде повратна 
вредност од овој метод.


Како што беше споменато претходно како задача потребно е да бидат искреирани останатите 
неколку методи за ``ContactRelation`` моделот и методите за преостанатите 
два модела со тоа што да не заборавиме дека за секој од нив потребно е најпрвин 
да бидат креирани тестови.


Django Unit Tests
-----------------

Многу важен дел денес од развивањето на една WEB 
апликација се нејзините тестови. Django  го користи истиот python модул што 
претходно го објаснуваме ``unittest``, што значи основите за тестирање во 
python веќе ни се познати и не би сакал повторно да се задржувам на нив.
За извршување на тестовите во django од командна линија се извршува 
следната команда::

   django-admin.py test
   
При што се извршуваат сите тестови во проектот. Доколку има потреба да се истестира 
само одредена апликација во продолжение се додава нејзиното име додека 
одреден модул може да се истестира со име на апликацијата точка името 
на тест класата од модулот::

   django-admin.py test app.TestContact
   
Django бара тестови во два модула од апликацијата и тоа модул со име 
``models`` и модул со име ``tests``.

Убава пракса е сите тестови да бидат организирани во еден пакет со име ``tests`` 
кој што се состои од модули со групи на тестови организациски поделени според 
одредена целина во апликацијата. Како на пример сите тестови за ``Contact`` 
модулот се чуваат во модул со име ``contact`` итн. За да бидат пронајдени овие 
тестови од страна на django името на тест класата за специфичниот модул мора да 
бидат импортувана во ``init`` модулот на ``tests`` пакетот.
Сите преостанати детали околу ``django unit tests`` може да ги прочитате во 
неговата 
`документација <https://docs.djangoproject.com/en/1.5/topics/testing/overview/#module-django.test>`_


Unit Tests во SocialNet
-----------------------

Во продолжение практично ќе покажеме како се пишуваат тестови во django и како 
истите се извршуваат. Пред да се започне со пишување на одреден метод во 
апликацијата потребно е најпрвин да се напишаат соодветните тестови за истиот, 
врз основа на кои подоцна ќе го биде напишан и самиот метод. За очекување е 
напишаните тестови на почетокот како што рековме и претходно да бидат погрешни.
Конкретен пример ќе разработиме за моделот за креирање на нов корисник во системот. 
Ги Знаеме параметрите кои што ни се потребни да креираме нов корисник, 
врз основа на нив го пишуваме тестот. ::

   class TestContact(ResourceTestCase):
    fixtures = ['auth.json', 'person.json']

    def setUp(self):
        super(TestContact, self).setUp()

        self.api_c = self.api_client

        # Login client
        self.api_c.client.login(username='admin', password='12345')

        self.user = user = Person.objects.get(pk=1)

        self.person_data = dict(first_name='Test',
                                last_name='Person',
                                username='test.person',
                                password='12345',
                                email='test@mail.com',
                                description='Test description',
                                phone='+2165125498425',
                                birthday='1989-12-01',
                                gender='MALE'
                                )

   def test_create_person_method(self):
           first_name = 'Test'
           last_name = 'Person'
           username = 'test.person'
           password = '12345'
           email = 'test@mail.com'
           description = 'Test description'
           phone = '+2165125498425'
           birthday = '1989-12-01'
           gender = 'MALE'
   
           new_person = Person.create_person(first_name, last_name, username,
                                             password, email, gender, description,
                                             phone, birthday)
   
           self.assertTrue(isinstance(new_person, Person))
           self.assertEqual(new_person.pk, 2)



Доколку го имате веќе разгледано погоре дадениот линк со детали околу django 
тестовите јасно ви е дека првиот дел од кодов претставува дефинирање на самата 
тест класа.
``Fixtures`` претставуваат податоци во ``json`` формат со кои што може да се 
работи во текот на тестирањето а кои што реално пополнуваат одредени објекти.
Пред извршување на секој тест django го повикува ``setUp()`` методот. 
Во овој метод се дефинираат променливи, објекти или извршуваме методи кои што 
се потребни во најголем дел од тестовите. Како пример ќе го земам методот за 
логирање на корисник овој метод е потребен во најголем дел од тестови, 
поради тоа за да не го повикуваме во секој тест посебно едноставно со повикување 
во ``setUp()`` методот тој се извршува за секој тест засебно.

 
Вториот дел од код-от на дадениот пример претставува метод чие што име започнува 
со ``test``, а веќе спомнавме дека секој метод во Тест класата што започнува со 
``test`` python односно django го препознаваат како тест. Во конкретниот случај 
потребно е да се провери дали со дадените податоци ќе се искреира нов објект од 
моделот Person и дали истиот е зачуван во база. Бидејќи веќе во ``fixtures`` 
има еден објект од моделот Person кој што е со ``id=1`` наредниот реално е да 
се очекува да биде со ``id=2``. На истиот начин ги креираме тестовите и за сите 
останати методи што ни се потребни за добивање на посакуваната функционалност 
на Person моделот.


Ова беше пример за дирекно тестирање на еден метод од одреден модел. 
Но исто така многу често потребно е да се истестира целосната интеракција 
помеѓу клиентот и серверот, симулирајќи соодветен клиент – сервер request, 
веднаш после нареднава целина ќе се вратиме  на тестовите обработувајќи 
ја оваа проблематика.


Django Forms
------------

При праќање на податоците од клиентска страна на сервер истите мора да се проверат 
односно да подлежат на валидација пред серверот да ги обработи. Во Django за 
сето ова е развиена библотека која што ги валидира податоците, враќа листа на 
грешки доколку некој од нив не е соодветен односно доколку валидацијата е успешна 
враќа податоци конвертирани во типот на променлива која што претходно ја имаме 
дефинирано за тоа поле. На тој начин во модел методите се добиваат податоци кои што 
одговараат соодветно на типот на секој од полињата во методот. 
``Forms`` библотеката има и останати примени но овде ќе се задржиме само на оваа.
`Поопширно <https://docs.djangoproject.com/en/1.5/topics/forms/>`_ за истата може 
да прочитате од django документацијта. 

Во продолжение ќе погледнеме пример за валидациска форма на методот за 
креирање на нов објект од моделот Person::

   class CreateNewPersonForm(forms.Form):
      first_name = forms.CharField(max_length=100)
      last_name = forms.CharField(max_length=100)
      birthday = forms.DateField(required=False)
   
Секоја форма претставува python класа која што наследува од ``forms.Form`` класата 
и во себе содржи инстанци од класи кои што дефинираат различни податочни типови. 
Односно тие го претставуваат секој еден податок кој што е потребно да се 
прима како влезен аргумент од клиентска страна.
Така на пример доколку е потребно да се креира нов објект од моделот Person со 
параметри ``first_name``, ``last_name`` кои што треба да бидат текст 
со максимална должина 100 карактери и истите се задолжителни полиња додека 
датумот на раѓање потребно е да биде во datetime формат и истиот не е задолжителен. 
Сето ова напишано преку Django Form е прикажано на горниов пример.


Forms во SocialNet
------------------
Во продолжение следуваат примереи од неколку форми во SocialNet додека остантите 
ќе биде потребно сами да ги искреирате. Откако е готов метод за креирање на 
нов корисник во системот потребно е да се креира валидациска форма за податоците 
кои што му се потребни на моделот. Да напоменам дека имињата на параметрите во 
формата потребно е да бидат исти со оние во моделот. Формата за креирање нов 
корисник во системот изгледа како на следниов пример::

   def validateGender(gender):
       """
           Validate that gender is one of the allowed.
       """

       if gender and len(gender) > 1 and gender not in GENDERS_MAP.keys():
           raise ValidationError(u'Invalid gender %s' % gender)

   class CreateNewPersonForm(forms.Form):
       first_name = forms.CharField(max_length=100)
       last_name = forms.CharField(max_length=100)
       username = forms.CharField(max_length=30)
       password = forms.CharField(min_length=5, max_length=30)
       email = forms.EmailField()
       description = forms.CharField(max_length=300, required=False)
       phone = forms.CharField(max_length=50, required=False)
       birthday = forms.DateField(required=False)
       gender = forms.CharField(validators=[validateGender], required=False) 
   

Карактеристично за оваа форма што досега го немаме спомнато е дека при 
дефинирањето на одредено поле може за истото да се напише и дополнителна валидација 
како на пример за ``gender`` потребно е како податоци да прима само 
``'NA',  'MALE',  'FEMALE'``, поради тоа ја пишуваме валидацијата ``validateGender`` 
и истата ја дефинираме во полето со дефинирање на дополнителен валидатор. 
Може да има повеќе од еден валидатор за едно поле.

Втора форма која што ни е потребна во апликацијата е онаа за едитирање на 
податоците на корисникот, која што изгледа вака::

   class UpdatePersonForm(forms.Form):
       first_name = forms.CharField(max_length=100, required=False)
       last_name = forms.CharField(max_length=100, required=False)
       username = forms.CharField(max_length=30, required=False)
       email = forms.EmailField(required=False)
       description = forms.CharField(max_length=300, required=False)
       phone = forms.CharField(max_length=50, required=False)
       birthday = forms.DateField(required=False)
       gender = forms.CharField(validators=[validateGender], required=False)
       
Оваа форма ги содржи истите полиња за валидација како и претходната со таа 
разлика што во овој случај сите од полињата се незадолжителни, односно само 
оние кои што се променети само тие ќе бидат испратени од клиентска страна 
за едитирање.

Последна форма која што ќе ја презентирам овдека е формата за промена на лозинка. ::

   class ResetPasswordForm(forms.Form):
       old_password = forms.CharField(min_length=5, max_length=30)
       new_password = forms.CharField(min_length=5, max_length=30)
       
Освен максимална должина постои можност да се дефинира и минимална должина на 
карактери за полињата кои што го побаруваат тоа, како на пример лозинка која што 
не смее да биде помала од 5 карактери а ниту поголема од 30 и за да се направи 
промена на истата потребно е корисникот да ја внесе и старата и новата лозинка задолжително.

Врз основа на документацијата за ``Django Forms``  и примерите дадени овде, 
останатите форми од апликацијата потребно е да ги направите сами.
